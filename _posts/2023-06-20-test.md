---
layout: post
title:  "test"
date:   2023-06-20
mathjax: true
---

We want the current state of the cell to change, if it was selected. That is, if the cell's index in the input array is a 1 then the user selected it and we want the compute shader to change the cell's state (from a 0 to a 1, or from a 1 to a 0). And if the cell's index in the input array is a 0, then we want the current state to pass through the compute shader unchanged. 

in other words we want the follow behavior:

<table style="
    width: 100px;
">
  <thead>
    <tr>
      <th style="text-align: center">input state</th>
      <th style="text-align: center">cell state in</th>
      <th style="text-align: center">cell state out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
    </tr>
  </tbody>
</table>

And this is just the truth table of the "exclusive or" \[xor\] operator. 

An expression ``` a ^ b ```, where ``` ^ ``` is the xor operator, is true only when either ``` a ``` or ``` b ``` is true, but not both. So the compute shader can find the current state of the cell, and the current state of the input array, from the cell's index, and then write the xor of those two states to the output buffer.

The compute shader operates on a vector whose x and y coordinates represent the cell’s coordinates in the grid. So we we’ll define a few helper functions to derive the cell index from the cell coordinates.

{% highlight rust %}
   /* find the cell index */
    fn cellIndex(cell: vec2u) -> u32 {
        return (cell.y % u32(grid.y)) * u32(grid.x) +
            (cell.x % u32(grid.x));
      }
    
    fn cellActive(x: u32, y: u32) -> u32 {
        return cellStateIn[cellIndex(vec2(x, y))];
      }
{% endighlight %}

Then the main function of the compute shader is pretty simple

{% highlight rust %}
    @compute @workgroup_size(64, 64)
    fn computeMain(@builtin(global_invocation_id) cell: vec3u){
        let i = cellIndex(cell.xy);

        /* inputState[i] xor currentState[i] */
        cellStateOut[i] = inputState[i] ^ cellStateIn[i];
            
    }
{% endhighlight %}

//describe work groups and work group size

The three inputs to this program are gird, an array of 2d float vectors; cellState, an array of 1’s and 0’s which represent the current state of each cell on the grid and inputState, another array of 1’s and 0’s which represents which cells have been selected by the user. These variables are defined in the compute shader like this

{% highlight rust %}
    @group(0) @binding(0) var<uniform> grid: vec2f;
    @group(0) @binding(1) var<storage> cellStateIn: array<u32>;
    @group(0) @binding(2) var<storage, read> inputState: array<u32>;
{% endhighlight %}

The `@group(0)` and `@binding(...)` declaractions specifie bindings within a *bind group*, which tells WepGPU how to connect variables to buffers.

The bind group for the compute shader is declared like this:

{% highlight javascript %}
  device.createBindGroup({
    label: "Cell renderer bind group A",
    layout: bindGroupLayout,
    entries: [
        {
            binding: 0,
            resource: { buffer: uniformBuffer }
        },
        {
            binding: 1,
            resource: { buffer: cellStateStorage[0] }
        },
        {
            binding: 2,
            resource: { buffer: cellStateStorage[1] }
        },
        {
            binding: 3,
            resource: { buffer: cellStateStorage[2] }
        }
    ],
  })
{% endhighlight %}

